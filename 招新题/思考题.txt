思考题1
1.css选择器的选择： 
  我认为选择器的主要作用在于选择，那么选择的范围与大小就应该是简洁代码的关键所在。首先，通过观察网上的大佬写代码，我发现几乎所有人写的第一个css都是*{margin:0;padding:0;boxsizing-border-box}这就提示着我们可以使用通配符选择器对页面进行一个”初始化“效果，让页面所以元素先执行这个效果。其次，将选择范围缩小，如果我们需要批量修改同种标签，则可以直接使用标签选择器对同一种标签进行修改。如果我要精确到某一个标签，那么可以使用类选择器，id选择器对该标签进行标记，这样我们就可以精确制导某个标签且不影响其他同类标签，或者也可以用结构伪类选择器直接选中一群相同标签中的第n个或第n到m个。 
  以上是我认为选择选择器的最基本的逻辑。然而，在大型的网页制作中，往往都会有标签套标签的结构，这时如果再用类选择器等‘精确度’高的选择器可能会面临一个大量类名的出现，造成了代码混乱。因此，我认为我们可以用范围中再圈范围的一个逻辑进行选择器的选择，即使用复合选择器。例如：如果我有两个标签，它们含有同一个类名的，都需要不同的样式，且它们处于两个不同的div中，这时我们可以给这两个div加上不同的类名如.front和.behind，通过后代选择器来区分出它们并分别进行修改，这样就可以精准修改两个标签而又不使它们相互影响。再比如，如果我发现两个标签大量样式相同只有小部分有区别时，我也可以通过并集选择器来简化代码，在轮播图的制作中，我设计了左右两个箭头，它们的位置，大小，颜色几乎是相同的，但方向相反，因此，我就通过并集选择器设置它们的宽高背景位置，再分别选中设置方向。
  如果我们有特殊效果的需求需要css实现，我们可以用伪类选择器来实现类似于鼠标事件的一些效果

2.元素居中的方法
  我还是用范围来确定一些元素居中的方法。1.如果是标签里的内容需要居中，可以用行高等于标签高度的方法实现垂直方向的居中，当然，这个指针对单行文字或内容来说，在水平方向的话可以用text-align中的center实现。2.对于标签之间，标签对于父级之类的居中的话，可以直接设置某个标签的内外边距，但是我认为这种方法虽然精准，但只适用少量标签的情形，如果涉及的标签过多，随之引入的可能是繁杂的数学计算和难以控制的盒子乱跑和溢出。还有flex布局，利用主轴和侧轴的对齐可以实现批量的元素居中。最后我还能想到的一点就是利用定位和平移来具体控制盒子或元素的位置

3. css的布局方法
  目前我了解的最多的布局方法是盒子模型布局，flex布局，定位布局，float布局等等。
  盒子模型布局：顾名思义，将我要显示的元素进行分区，一部分标签统一放到一个盒子，另一部分则放在另一个盒子中，它让网页变得更加有序，这种布局几乎是在所有网页布局中是看的到的，随便打开一个网页，就可以发现一个个有间隔并且有序排列的盒子。此外，基于盒子模型所引起我的一个思考是：盒子其实和js中的函数是有异曲同工之妙的，它们都是通过限制一定范围将零碎的元素或代码组装在一起发挥应有的功能，使代码本身更加结构化和有序
   flex布局：这个布局使大盒子中的元素或标签能够排列在一个水平方向。就想上面说的，对批量元素的居中操作，或许用这种布局就是个不错的选择，此外，同一水平方向的导航，轮播图下方的圆点等等都离不开flex的布局操作。
   定位：这个是我目前比较喜欢的布局方式，通过父级的相对定位和子级的绝对定位可以实现子级位置的调整和子级元素的重叠，像一些小的文字盖在一个盒子上的效果都可以用定位实现。定位主要以影响重叠效果为主，与flex和盒子模型对比，不妨可以这样理解定位：定位的重叠效果可以认为是空间中z轴变化所引起的，而我们观察屏幕的方向即为z轴方向，另外两个方向则以你主动设置为准，盒子间一般不会又太多相互影响，不会出现太多错乱的情况，而另外两个布局则可以认为在xy方向上的距离变化，因此定位相对而言，出现盒子乱飘的现象就比较少，其主要影响在于盒子的重叠问题，这也是一个比较喜欢用定位的原因。
  float布局：这种布局也是应用与父子级之间，子代标签设置了float后会依次在对应方向排列，它可以用来做文字环绕效果。
4.对不同分辨率手机进行适配的原因是同一张图片在固定了宽高之后只能在当前网页显示对应大小，在拿到其它设备时，图片可能会因大小不适配而糊掉。通过一种方法使图片等内容可以在不同设备中按比例伸缩，保存最真实的图片，这就是移动适配的意义。
我所了解的适配方案主要有rem和vw，它们的原理都是通过将px这种固定单位变成一个相对单位，也可以理解为一个单位换算的问题
思考题2
1. JavaScript主要的数据类型有数字型，字符串，布尔，undefined, null，以上这样为简单数据类型，数组，对象，正则表达式（这样是复杂数据类型）等等。关于函数是否是一种数据类型，其实是我一直在思考的问题，首先，函数定义的方法可以与普通数据类型相同，也可以不同，通过变量的本质来看，变量由一个名字和一个值组成，这个值的类型就可以是任意数据类型，那函数我似乎也可以理解为它也可以放到一个变量里，而它的值比较特殊，就是返回值，所以我认为函数也应该是一种数据类型。与其它语言相比（主要与c语言相比），JavaScript中几乎所有的变量或常量都可以表示为：let 变量名= 值，var 变量名=值，const 常量名=值，其中值可以替换为以上数据类型的对应的值，换言之，我们甚至可以理解为JavaScript中，一个数据类型是由值定的，let x=1，那就是数字型，let x=true,那就是布尔型，而在c语言中，我们需要对变量先定型，再命名，再赋值，例如int x=1，x为整型，float x=1，x为浮点型，而且整形和浮点型还分为更多类型，JavaScript就不分整型和浮点型。由此观之，JavaScript对数据类型的要求是比较随意的，对变量的命名也是自由的
2. JavaScript判断数据类型的方法有：
typeof，typeof 变量名或常量名  这个是它的使用方法，这种方法语法简单，直接输出对应数据类型但不能检测复杂数据类型
由于在目前学习中没有太多用到数据类型检测，所以目前能熟练应用的只有typeof
根据资料查询，还可以检测数据类型的方法有：constructor：获取变量构造函数，返回布尔型
instanceof:检查变量是否属性某个构造函数的实例，也返回布尔型
1. dom操作在元素的样式修饰中，可以按照我的要求与逻辑获取元素，精准定位修改样式。但是，dom精确操作某个元素样式的同时也反应了它的缺点，它不能对元素进行批量操作，也就是说元素样式的批量修改离不开套入选择器进行属性大量添加，即使通过classlist等方法添加的仍然是对选择器的增删替换进行操作。从这里，我们就可以看出dom和css如何联合使用：我们可以用css写好需要对元素改变的属性，并套在一个选择器中，再通过dom中classlist等方法进行选择器的增删替换，实现交互中的属性批量修改。同时，单一样式就可以直接通过元素名. style.属性名=属性值的方法进行修改。
我更喜欢用dom，在dom操作过程中可以使我更加有逻辑地去编写代码，获取元素，修改样式。也就是说，进行dom操作时，我可以清晰地想到：我要获取什么元素，我要修改它的什么样式，我要怎样修改的这样一个流程。在css操作中，正由于属性的大量添加，有时会让人产生一种属性堆积的混乱感，让人觉得逻辑没有这么强烈了。这样使我在写css时往往是想一条加一条，逻辑是零散的。
2.可以用一句通俗的话描述css的作用："我选了哪些东西，我要改什么，我要改到什么程度"，它们分别对应了选择器，属性名，属性值，它们贯穿一个网页制作的始终，是实现网页功能和视觉体验的不可或缺的东西。选择器是联通JavaScript中dom与html标签的桥梁，让JavaScript从基本语法与其他语言大致相同的语言转变为作用与浏览器的交互语言。属性名覆盖着整个网页可变化的东西，一个属性名下有包含多个展现在浏览者眼前的属性值。属性值的变化是交互发生的体现，也是网页功能实现的本质。因此，网页大量功能都与JavaScript操作css有关。对css的理解和运用能力我认为是一个前端工作者至关重要的东西，一个网页的下限是目的功能的实现，那么它的上限就是如何产生更好的视觉体验，如何让页面更美观，这里css就起到了决定性作用。更深入了解css也是我目前需要进一步学习的
1. JavaScript中存在事件捕获和事件冒泡的概念。至于哪个事件先发生，需要分情况讨论：如果对应元素进行过事件捕获，那么事件会从父元素发生，再发生子元素事件。如果没有设置事件捕获，那么默认发生事件冒泡，即反过来子元素先发生，父元素后发生
2. JavaScript对代码的运行是具有一定的优先级的，用专业术语说就是同步任务和异步任务，网页会优先执行那些脱离于一些特殊函数之外的零散代码，代码执行过程中在遇到特殊函数，事件，定时器等时，会将它们这类看着比较“大”的东西提到一边，等简单而零散的代码执行完后再按照顺序执行这些函数，如果这些函数中又有零碎的代码和这类特殊函数，则会接着进行上述操作。由于零碎代码运行速度很快，所以其时间上的细微差别不易被我们察觉，加上对代码的优先级处理，让我们认为网页可以同时进行一系列数据处理工作
思考题3
1.这个文件还是会被忽略，在执行其它操作时这个文件将不会被执行
2.首先应该撤销本次提交并撤销到某一步，然后修改错误的内容和提交漏掉的文件，针对一个人的开发必要是可以使用reset来保持历史提交干净
3. reset会删除一些历史提交，生产时一般为多人操作，每个人可能会提交到同一个历史提交，因此使用reset可能会将别人的历史提交也删除

